# `start.sh`

## `maintenance` mode

No installation, just a running container ready for inspection
In an interactive shell you can run the scripts to install, load and run.

## serving modes

There are two serving modes

* `production` (apache);
* `develop` (Web2py development server).

Note that the source container is mounted in at `/app`.

We run several scripts:

1.  `install.sh` : installs missing bits on `/app/run`;
1.  `load.sh` : Loads missing databases in the `shebanqdb` container;
1.  `run.sh` : starts the serving process in the background.

We catch the PID of the serving process and wait for it to be interrupted by Ctrl+C,
on which the process will get terminated.
This approach will prevent docker compose to wait 10 seconds
before killing the process.


# `install.sh`

First of all: configuration!

Some environment variables (defined in the `.env` file) will be written to
configuration files. These files are used to access the database, for example.

Between restarts of the container the values of these variables may have changed.
So, whenever we start a container, we make sure that these files are written out,
first thing.

Note that also the value of the Web2py admin password is written to disk, not
in this step, but in `install.sh` below. That also will be done every time, after
Web2py is installed. 

The `shebanq` image contains the following installed software:

1.  **EMDROS**
    (database extension software)

    Offers the `mql` command in `/opt/emdros/bin/mql`.

1.  **APACHE**
    (web server)

    Offers the `apachectl` command. 
    The web server is configured for WSGI and has the configuration for the
    shebanq website in place.

However, the software of SHEBANQ is not yet in place.
SHEBANQ is a python/javascript website that runs in the Web2py framework.

We need to set up Web2py and Shebanq in this step.

When the shebanq container starts up, it verifies whether Web2py and Shebanq
are installed, and if not, it will install what is missing.
It can install Web2py and Shebanq independently. It takes care that in all cases
Shebanq will be hooked neatly inside Web2py.

However, we will not install Web2py and Shebanq inside the container,
but in the source volume, under the `run` directory, so in `/app/run`.

---

**Q**: Why did not we install it before starting the container then?

**A**: Well, some of the installation steps involve running code in the container:
we run several functions of Web2py, using the Python that runs in the container.
These steps involve compiling Python code to bytecode, and if we did that
from the outside, the risk is that the bytecode generated in this way is not
compatible with the Python that runs inside the container.

---

**Q**: Why not install it inside the container?

**A**: Then we loose the result of the installation whenever we restart the container.
Moreover, some data that will be generated by the service, ends up within these
directories, and will get lost if the container is restarted.

---

## Details

### Configuration

The first step is writing some config files that help programs to conveniently
access the databases. The secrets in these config files are obtained from
environment variables in the `.env` file.

The files end up in `/app/run/cfg`

### Web2py

Web2py comes as a zip file in the `src` directory of the repo.
It will be unzipped to `/app/run/web2py`.

Then we do the following steps:

1.  After that it will be patched to prevent some Python warnings and to remove the
    restriction that the admin interface can only work over https.
    See
    [here](https://github.com/smithmicro/web2py/blob/17a3afce0c368b5ab83ea941b81934851eddaafb/entrypoint.sh#L38).

1.  We configure Web2py over `htpp` only, a proxy will take care of https.
    So Web2py only sees HTTP requests, and would never allow the admin interface.

1.  We set a password for the admin interface, by calling a method of Web2py.
    This will generate a file `parameters_ppp.py` in the `web2py` directory, which is
    a hash of that password, and needed by Web2py to authenticate admins.

    **This step will be done every time,
    regardless whether Web2py was installed or not.**

1.  If shebanq is already present, it will be linked to from the `application`
    directory.

1.  We put some custom files in place and remove some unneeded material.

1.  We make sure that several writable directories are present within the admin app of
    Web2py. We give `www-data` ownership of these files.

1.  We compile the admin app, by using a Web2py command to make a web-app readily
    available.

1.  We python-compile the python code in the modules of the admin app.

### Shebanq

Shebanq comes as a source code directory in the `src` directory of the repo.
It has the structure of a Web2py application, like the admin application mentioned
above.
Its subdirectories will be copied to `app/run/shebanq`, if they are not already
there.

---

**Q**: Why not copy the complete directory at once?

**A**: Shebanq will gather other materials in the course of its operation:
errors, logs, uploads, etc and they arrive in its writable directories.
We do not want to loose that information when we restart the container.

---

Then we do the following steps:

1.  We make sure that several writable directories are present within the shebanq app.
    We give `www-data` ownership of these files.

1.  If `web2py` is already present, we create a soft link from its `application`
    directory to shebanq.

1.  We compile the shebanq app, by using a Web2py command to make a web-app readily
    available.

1.  We python-compile the python code in the modules of the shebanq app.


# `load.sh`

Loads the SHEBANQ databases, in as far as they are missing.

It will always perform the setting of the correct grants for the user `shebanq`
in the database. This is the user on whose behalf the shebanq web-app connects
to the database system.
Precisely the right grants are instated.

After this it will load:

*   static data containing the texts and linguistic annotations;
*   dynamic data contributed by users: queries and notes and admin details.

## Static databases

They are available in `/app/src/databases`
(which is a directory that is synchronised with GitHub).

The Hebrew data comes in several versions, from old to new:
`4 4b c 2017 2021`

For each *version* there are two databases:

*   `shebanq_passage`*version* :
    ordinary SQL data, contains the text of the verses,
    optimized for displaying the bible text;
*   `shebanq_etcbc`*version* :
    *MQL* data,
    contains the text plus linguistic annotations by the ETCBC,
    optimized for executing MQL queries.

You cannot restrict the versions in SHEBANQ, because the shebanq app has logic
that deals with these versions. This logic breaks if any of the known versions
is missing.

## Dynamic databases

They may be available in `app/secret`
(which is a directory that is *not* synchronised with GitHub).

There are two databases:
*   `shebanq_web` : user details, saved queries;
*   `shebanq_note` : saved notes.

When you want to import pre-existing data, they should have been exported as
SQL exports and show up in `app/secret`.
Remove existing databases with these names from `_temp`
(a directory that is also not synchronized with GitHub).

If there are no previous dynamic databases within reach,
the databases will be created with the right data model and empty content.

You can also enforce to start with empty databases by the environment variable
(in `.env`):

```
emptyuserdata=v
```

Note that `shebanq_note` has foreign-key dependencies on `shebanq_web` :

*   When deleting: first delete `shebanq_note`, then `shebanq_web`;
*   When importing: first import into `shebanq_web`, then into `shebanq_note`.


# `run.sh`

Runs shebanq in various parts and modes, triggered by the first command line
argument:

*   `production`: starts Apache;
*   `develop`: starts the Web2py development server;
*   `test-shebanq`: tests the main controller of SHEBANQ.

This script is called by `start.sh` with arguments `production` or `develop`,
depending on the `runmode` environment variable.

But it can also be used in a shell inside a running shebanq container.
